# 003. Longest Substring Without Repeating Characters

//------------------------------------------------------------------------- //Approach \#1 // Using HashSet. // t: O\(n^2\) // s: O\(n\) class Solution { public int lengthOfLongestSubstring\(String s\) { if \(s.length\(\) == 0\) return 0; char\[\] S = s.toCharArray\(\); int max = Integer.MIN\_VALUE; for \(int i = 0; i &lt; S.length; i++\) { HashSet set = new HashSet&lt;&gt;\(\); set.add\(S\[i\]\); for \(int j = i + 1; j &lt; S.length; j++\) { if \(set.contains\(S\[j\]\)\) { break; } else { set.add\(S\[j\]\); } } max = Math.max\(max, set.size\(\)\); } return max; } }

//----------------------------------------------------------------------- // Two pointer. One-pass. // t: O \(n\) // s: O \(n\) class Solution { public int lengthOfLongestSubstring\(String s\) { HashMap map = new HashMap&lt;&gt;\(\); char\[\] S = s.toCharArray\(\); int res = 0; for \(int i = 0, j = 0; i &lt; S.length; i++\) { if \(map.containsKey\(S\[i\]\)\) { j = Math.max\(j, map.get\(S\[i\]\) + 1\); } map.put\(S\[i\], i\); res = Math.max\(i - j + 1, res\); } return res; } }

//------------------------------------------------------------------------------ // Similar with approach \#2, but using array to store the index. class Solution { public int lengthOfLongestSubstring\(String s\) { int\[\] table = new int\[128\]; char\[\] S = s.toCharArray\(\); Arrays.fill\(table, -1\); int max = 0; for \(int i = 0, j = 0; i &lt; S.length; i++\) { j = Math.max\(j, table\[S\[i\]\] + 1\); table\[S\[i\]\] = i; max = Math.max\(max, i - j + 1\); } return max; } }

